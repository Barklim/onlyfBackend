kliment.barkalov@gmail.com
klim.barkalov@mail.ru
suser@gmail.com
test@mail.ru
123123456456

принять приглашение/ мое агенство чекбокс/ storybook host
Remember me ?
похоже notificationscount почему-то ререндерит все приложение 
user.lastActivity 2023-12-02T02:21:27.348Z
user.emailConfirmedDate
//
- **Data fetching**: `miragejs`, `faker`
//
How to bypass reCAPTCHA with Puppeteer and Headless Chrome
https://www.youtube.com/watch?v=wsDRkAD6lPs&list=WL&index=20&t=5s&ab_channel=JarrodOverson
//
https://docs.google.com/document/d/1AzK-DPn4afeKjbFumDeF8AAt43GbS3MwgyBkyZNAR70/edit?copiedFromTrash
//
https://mangoai.co/    bot
https://quickqr.art/
https://www.adultaitools.com/tools/chatpersona-ai
https://chromewebstore.google.com/detail/onlyfans-ai-chat-tool-cha/bgefplnmcbmcfjmggpjiadldmfiiecma
https://www.fanvue.com/
//
https://freelance.habr.com/tasks/515565
//
asdf1234
kliment.barkalov@gmail.com
test123123@gmail.com
//
как установить расширение с мобильного

await get("UserRepository").update({ id: 'fac32de4-6e21-4ba2-a312-865d2b20b98c' }, { role: 'admin' })

npm run start -- --entryFile repl

await get("UserRepository").find();
await get("UserRepository").findOne({ where: { id: 10 }})
await get("UserRepository").update({ id: '9cf0703c-31ad-495c-85f7-b95c1d2055c8' }, { role: 'superuser' })
await get("UserRepository").update({ id: '0ab948f6-2947-486b-9171-a105867628fe' }, { online: false })
await get("UserRepository").update({ id:  10 }, { roles: ['admin'] })
await get("UserRepository").update({ id:  9 }, { roles: ['model', 'regular'] })
await get("UserRepository").update({ id:  11 }, { roles: ['admin', 'regular', 'manager'] })
await get("UserRepository").update({ id:  10 }, { roles: ['regular', 'manager'] })
await get("UserRepository").update({ id: '0ab948f6-2947-486b-9171-a105867628fe' }, { roles: ['model'] })
await get("UserRepository").update({ id: '0ab948f6-2947-486b-9171-a105867628fe' }, { role: 'model' })
await get("UserRepository").query(`
  UPDATE "user"
  SET settings = jsonb_set(settings, '{isVisible}', 'true'::jsonb)
  WHERE id = '9cf0703c-31ad-495c-85f7-b95c1d2055c8'
`);
await get("UserRepository").clear();
await get("ApiKeyRepository").find();
await get("ApiKeyRepository").clear();
//
await get("UserRepository").query('TRUNCATE TABLE "user" CASCADE');
await get("ApiKeyRepository").query('DELETE FROM "api_key"');
await get("UserRepository").clear();
//
await get("ProfileRepository").find()
await get("ProfileRepository").findOne({ where: { id: 23 }})
await get("ProfileRepository").findOne({ where: { id: 23 }})
await get("ProfileRepository").update({ id:  23 }, { verified: false })
await get("ProfileRepository").update({ id:  23 }, { username: 'test' }) // 6
await get("ProfileRepository").update({ id: 8 }, { username: 'test klim' }) // 5
await get("ProfileRepository").update({ id:  7 }, { online: true }) // 6
await get("ProfileRepository").update({ id: 9 }, { online: true }) // 5
// 49  54
await get("ProfileRepository").update({ id:  49 }, { isVisible: true })
//
await get("ProfileRepository").query('TRUNCATE TABLE "profile" CASCADE');
await get("UserRepository").query('DELETE FROM "profileId"');
await get("ProfileRepository").clear()

await get("ScrapperRepository").find()
await get("ScrapperRepository").update({ id: 5 }, { status: 'offline' })

await get("AgencyRepository").delete({ id: 17 })
await get("AgencyRepository").find()
await get("AgencyRepository").clear()

await get("NotificationRepository").find()
await get("NotificationRepository").clear();


await get("MessageRepository").find()
await get("MessageRepository").find({ id: 40  })
await get("MessageRepository").delete({ id: 3 })
await get("MessageRepository").clear()

await get("IncidentRepository").find()
await get("IncidentRepository").findOne({ where: { msgId: '2120383370444a01114' }})
await get("IncidentRepository").update({ id:  124 }, { incident_created_at: '2023-11-19T00:01:06.531Z' })
await get("IncidentRepository").update({ id: 111 }, { incident_created_at: '2023-11-18T00:01:10.032Z' })
await get("IncidentRepository").update({ msgId: '2120383370444a01114' }, { incident_created_at: '2023-11-18T23:59:40.080Z' })
await get("IncidentRepository").delete({ id: 98 })
await get("IncidentRepository").clear()

await get("ProfileRepository").delete()
await get("ProfileRepository").query(`DROP TABLE IF EXISTS ProfileRepository`);
await get("ProfileRepository").query(`DROP TABLE IF EXISTS Profile`);
await get("ProfileRepository").query(`DROP TABLE IF EXISTS ProfileRepository`);
await get("UserRepository").query(`DROP TABLE IF EXISTS UserRepository`);



до диалогов первая
скоро, стоп слова
2-3 недели
массовые рассылки,
списки пользователей, перевод
2-3 недели
статистика
подписчики, финансы и ссылки
https://www.onlinepalette.com/onlyfans/

https://onlyfans.com/api2/v2/chats?limit=10&offset=0&skip_users=all&order=recent
unreadMessageCount

docker run --name postgres -e POSTGRES_PASSWORD=pass123 -e POSTGRES_DB=postgres -p 5432:5432 -d postgres



## TODO

todo доделать ui нотификаций
https://mui.com/material-ui/react-snackbar/#customization

получить агенство на странице профиля, для того чтобы можно было выставлять настройки времени.
указывать в карточке email пользователя для админов
//
showtutorial

search 
entitymanager typeorm
проверить все методы на доступы к апи
удалить сервисы нотификаций по ролям
Проблемы с roles
https://www.creatorhero.com/
https://www.creatorhero.com/old-home
https://getbotly.com/
https://www.adultcreator.co/best-onlyfans-management-softwares/
//
ui
https://www.gptgirlfriend.online/
https://gravity-ui.com/
https://cloud.yandex.com/en/services/datalens
//
https://www.businessinsider.com/how-to-start-an-onlyfans-without-followers
https://telegra.ph/Paru-slov-pro-OnlyFans-agentstva-07-21#:~:text=%D0%9E%D0%BD%D0%BB%D0%B8%D1%84%D0%B0%D0%BD%D1%81%2D%D0%B0%D0%B3%D0%B5%D0%BD%D1%82%D1%81%D1%82%D0%B2%D0%B0%20%2D%20%D1%8D%D1%82%D0%BE%20%D0%BA%D0%BE%D0%BC%D0%BF%D0%B0%D0%BD%D0%B8%D0%B8%2C,18%2B%20%D0%B7%D0%B0%D1%80%D0%B0%D0%B1%D0%B0%D1%82%D1%8B%D0%B2%D0%B0%D1%82%D1%8C%20%D0%B4%D0%B5%D0%BD%D1%8C%D0%B3%D0%B8%20%D0%BD%D0%B0%20OnlyFans.
https://www.google.com/search?q=+dialog+icon&tbm=isch&ved=2ahUKEwjMiKeRhs6BAxXJm2MGHdHnBtQQ2-cCegQIABAA&oq=+dialog+icon&gs_lcp=CgNpbWcQAzIHCAAQigUQQzIFCAAQgAQyBQgAEIAEMgYIABAHEB4yBggAEAcQHjIGCAAQBxAeMgYIABAHEB4yBggAEAcQHjIGCAAQBxAeMgYIABAHEB46BAgjECdQxAxYxAxg0g5oAHAAeACAAUKIAYEBkgEBMpgBAKABAaoBC2d3cy13aXotaW1nwAEB&sclient=img&ei=DdUVZYzOEMm3juMP0c-boA0&bih=879&biw=1920
https://www.google.com/search?q=in+maintenance+material+ui+component&tbm=isch&ved=2ahUKEwiE85yqyMqBAxUAz6ACHU6nCEsQ2-cCegQIABAA&oq=in+maintenance+material+ui+component&gs_lcp=CgNpbWcQA1DKCVihEGDPEWgAcAB4AIABgAGIAegCkgEDMy4xmAEAoAEBqgELZ3dzLXdpei1pbWfAAQE&sclient=img&ei=lwEUZcTLE4Ceg8UPzs6i2AQ&bih=847&biw=1920#imgrc=jByPuyYSsGKU1M
pricing
https://mui.com/material-ui/getting-started/templates/
grpc
https://coursehunter.net/course/grpc-node-js-master-klass-sozdanie-sovremennyh-api-i-mikroservisov






дай детальное решение по архетиктурному проектированию системы веб приложения ниже

Необходимо разработать расширение для браузера с серверным приложением и веб-админкой, в которой выводится агригированная статистика, собранная предварительно через веб расширение. В веб админ панели можно экспортитровать таблицы.
//
Бизнес задача ставиться следующим образом.  Существует два типа аккаунтов, в одном время разделено на части с 0 до 6, с 6 до 12, с 12 до 18, с 18 до 24 часов, в другом с 2 до 10, с 10 до 18, с 18 до 2 часов.

Необходимо через расширение отслеживать все запросы к чату и отправлять запрос на бэк о текущих не прочитанных чатах и времени запроса.
POST /api/v1/chat/status { ids: [], timestamp: Date }
Либо сам бэк должен отправлять каждые 3-5 мин запрос, в к api для отслеживания текущих непрочитанных чатов. Необходимо хранить все не прочитанные сообщения в reddis.
В случае если id чата живет дольше 15 мин отправить уведомление. Данное сообщение c cопутствующей информацией сохраняется в postgres в таблице chats.

Запрос возвращает все отфильтрованные данные из таблицы chats. Response отдает x, вместе с рассчетом о задержках.
GET /api/v1/chat/report?startDate=x&endDate
p.s. нужно разделять запросы по таблицам к chats, dialog, e.t.c.

Запрос
GET /api/v1/chat/stopwords
возвращает массив запрещенных слов. Этот запрос используется расширением и делается не реже 5 минут. Либо возвращать эти данные при авторизации. Эти слова учитываются при наборе текста в инпуте сообщения и блокируют кнопку отправки, в случае наличия. Когда данное слово находится в инпуте, то дебаунсом секунд в 30 должен отправляться запрос с текущим текстом.
POST /api/v1/chat/report { text: '' }
p.s.
Было бы здорово отправлять запросы к chatGpt, с проверкой на наличие различных настраиваемых нюансов, типо негатива, расизма, негатива.

Запрос
Post /api/v1/chat/stopwords { stopWords: [] } Из админки меняет этот набор слов. Эти слова возможно сохаряются в 1ой таблице либо в каждом пользователе, если у каждого аккаунта разные стоп слова.

Необходимо уточнить нюансы учета диалогов по сеансовым ограничениям.
Браузерное расширение берет данные предположительно из запроса авторизации данные о текущей смене. Отсюда можно проверить условие начать активный диалог. Запрос
Post /api/v1/dialog/

Планировщик (sceduller) должен под кредами всех существующих пользователей собирать статистику по соотвествующим таблицам.
mailings (массовые рассылки).
p.s.
сюда же collections, subscribers (online), finance

Веб расширение создает веб-сокет подключение, которое отображается в админке c каждого пользователя.

1.6 необходимо конкретизировать. Но в сухом остатке это все туда же в sceduller в таблицу collections.

Интеграцию с переводами оставить на конец как самую менее важную, с точки зрения технической.

Подписчики в sceduller

Финансы в sceduller

Ссылки в sceduller. Нужно будет разобраться в том, что необходимо.


Summary:

Для данного программного решения необходимо реализовать авторизацию.
Предполагаются модели:
- пользователей, чатов, диалогов, а также все спаршенные под статистику таблицы collections, subscribers, finance, x.

Бэкенд на nest,js, sceduller. Базы данных postgres, reddis (для кол-ва непрочитанных соощений). Фронт часть react, админ панель . Расширение держит вебсокет, который будет остслеживать подключение к аккаунту для вывода текущего состояния в панель клиента.

время настраиваемое


## description

OnlyFans Tracker (OFTracker) для операторов +ChatGpt , представляет из себя:
chrome extension, 
react приложение,
nest js бэкенд, 
json-server для мока данных во время разработки клиентского приложения. 
Оператор имеет доступ к n-му количеству аккаунтов сервиса only fans (OF). Скачивает расширение из веб приложения и устанавливает в браузере Dolphin. Оператор регистрируется либо, если аккаунт создан авторизуется в расширении и далее расширение собирает статистику по работе оператора и имеет дополнительные функционал. Вот некоторые фичи:
1. Cлежение за скоростью ответа в месенджере OF. При нарушении, то есть слишком долгом ответе условно 15 минут, это идет в статистику нарушений, со всей информацией о событии.
2. Блокировка инпута ввода в OF в случае введения запретного слова. Запретные слова настраиваются админом в настройках веб приложения. Слово и связанная с событием информация идет в статистику нарушений. Каждый n-ый запрос имеет интеграцию с ChatGpt с промптом на агрессию и соответствие качествам характера модели.
3. Как и в клиентском приложении показывается online status оператора о сборе статистики.
4. Сбор статистики активных диалогов, информации о пользователях, массовых рассылках и финансах, возвратах.

Бэкенд.
Каждый админ связан со своими операторами и может настроить стоп слова и время отклика оператора на сообщения в OF. Пользователь с ролью админ может связать себя с оператом отправкой инвайта в приложении. Когда произошла 2х стороння привязка и аккаунт верфифицирован админом, с этого момента авторизованным оператором в OFTracker extension собирается статистика. Доступ к ресурсам реализован с помощью подхода role based access control. 
Безопасность включает в себя:
1. JWT авторизация через ротацию пары access, refresh токенов.
2. invalidate tokens. automatic reuse detection
3. 2-3хфактурную авторизацию по стратегии почты или скана qr code. Для оператора верификация по почте, для админа дополнительно по qr code. 

В качестве базы данных выбран redis, так как приложение предпологает система очередей сообщений, быстрая и надежная система кэша, а также TTL, для некоторых программных сущностей. C другой же стороны приложение не предпологает сложных динамических данных.

Клиентское приложение  Поддерживается темизация и интерационализация приложения.
Технология Material UI, Redux RTK, feature sliced design e.t.c.
OFTracker fronted позволяет следить за своей статистикой операторам и статистикой моделей и оператовров админами. 
Админы могут следить за активностью и статистикой своих операторов и моделей. Админ имеет доступ ко всем привязанным пользователям с ролью user и manager и имеет доступ к чтению и изменению данных в профиле. Админ присваивает пользователям с ролью модели id из onlyfans в профиле пользователя с целью привязки модели пользователя ‘модель’ к id моделей из сервиса OF.
Админы могут привязать к себе оператора и в дальнейшем верифицировать или отменить верификацию оператора с целью доступа к сбору статистики в OFTracker extension.


## extension

https://github.com/ElishaKay/udemy-fullstack-chrome-extension
https://stackoverflow.com/questions/63308160/how-to-migrate-manifest-version-2-to-v3-for-chrome-extension

background
launched when browser started or extension loaded
terminated when browser closed extension removed

popup
launched when extension button pressed

options
launched when user open option page

content script
launched when specified URL opened in tab


## accounts

и история нарушений в виде таблицы
дата сообщения которое пришло, дата когда ответила/либо нул, имя пользователя


## todo

https://fansmetric.com/
onlyfans ui
/api/...
errors, by notifications
so many notifications services
проверить разрешения настройек по отправке уведомлений
добавить метод для публикации инфо уведомлений.
smtp gmail to sendgrid
apiKEY,
accept cookie UI banner
//
kliment.barkalov1@gmail.com
samaca-ludu-rajewa
//
user 1 chipxvxcbohn@outlook.com
user 2 a.grininathai@gmail.com
user 3 hello.kakdela@outlook.com
//
chipxvxcbohn@outlook.com
a.grininathai@gmail.com
hello.kakdela@outlook.com

Пароль:
Pirsing0
// -----
учесть то что с каждого таба может идти запрос лишний на сбор статистики
logout?
activate
запросы идут через cookie
закладка как fansmetrick справа


EXTENSION
Добавлены иконки для расширения с со статусами error, success, warning. Добавлены экшены, которые меняют иконку в extension bar.
issue: Возможна проблема с дублированием вкладки, так как у таба одинаковый id создается

305308498
305308472
без setTimeout, как дождаться загрузки
сделать reload расширения когда теряется коннект с странице скреппинга. Reload должен открывать страницу скреппинга
попробовать сделать запрос сохранить его, отложить на 5 сек, самому походить на другой и повторить предыдущий.

sign 12973:a5d6010dde3e70742d241d111d55e610781069a0:504:652d3184
user2 = 279424382


app-token 33d57ade8c02dbc5a333db99ff9ae26a
sess ikrdif8e06kufa8h4sdmp1kls2
auth_id 276910264
user-agent Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/117.0.0.0 Safari/537.36
x-bc e869127d6a4d4e3035fb9e1ad6d12555ab6c59f0


?
redisClient

npm run start -- --entryFile repl

await getCustomRepository(UserRepository).clear();
await get("UserRepository").findOne({ where: { id: 90 }})
await get("UserRepository").findOne({ where: { id: 173 }})
await get("UserRepository").update({ id:  91 }, { role: 'superuser' })
await get("UserRepository").update({ id:  173 }, { role: 'regular' })

await get("ScrapperRepository").find()
await get("ScrapperRepository").update({ id: 5 }, { status: 'offline' })
await get("UnreadMessagesRepository").find()
await get("UnreadMessagesRepository").delete({ id: 2 })

await get("MessageRepository").find()
await get("MessageRepository").find({ id: 40  })
await get("MessageRepository").delete({ id: 3 })

await get("AgencyRepository").delete({ id: 17 })
await get("AgencyRepository").clear();
await get("AgencyRepository").find()

await get("NotificationRepository").find()
await get("NotificationRepository").clear();

зашифровать пароли для кредов
user/me - это в хедере User-Id:
112299545


changedAt:"2023-10-27T02:04:46+00:00"
createdAt: "2023-10-27T02:04:46+00:00"
fromUser.id = 112299545


// id чата 122754683
https://onlyfans.com/api2/v2/chats/122754683/messages?limit=10&order=desc&skip_users=all&id=2119526509867
https://onlyfans.com/api2/v2/chats/122754683/messages?limit=10&order=desc&skip_users=all&id=2111525050392

по чатам такое апи
https://onlyfans.com/api2/v2/chats?limit=10&offset=0&skip_users=all&order=recent
list.lastMessage
list.lastReadMessageId
list.unreadMessagesCount